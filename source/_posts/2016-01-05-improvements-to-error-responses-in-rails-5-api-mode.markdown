---
layout: post
title: "Improvements to error responses in Rails 5 API mode"
category: 
comments: true
author:
  name: Jorge Bejar
  email: jorge@wyeworks.com 
  twitter_handle: jmbejar
  github_handle: jmbejar
  image: /images/team/jorge-bejar.jpg
  description: Software Engineer at Wyeworks. Ruby on Rails developer.
---

In previous posts, we showed how to build an API application with Rails 5. Specifically, we covered the integration with [Backbone](https://wyeworks.com/blog/2015/6/11/how-to-build-a-rails-5-api-only-and-backbone-application) and [Ember](https://wyeworks.com/blog/2015/6/30/how-to-build-a-rails-5-api-only-and-ember-application). At time of writing these posts, the only way to try out all the new Rails API mode was taking the code from the master branch, since Rails 5 had not been released yet. However, [Rails-5-0-beta1 is available now](http://weblog.rubyonrails.org/2015/12/18/Rails-5-0-beta1/), so you can easily start to build applications using Rails in its new API-flavored mode.

This Rails release also includes some changes related with the API mode that landed in Rails a few weeks ago. The purpose of those changes are [improving error responses for JSON requests on Rails]. We initiated a discussion about how Rails should handle and return responses in a proper format in case of errors processing a request, and then [we](https://www.wyeworks.com) finally came up with [the necessary code changes](https://github.com/rails/rails/pull/20831) in Rails.

<!--more-->

Before digging into how error responses were improved, let's recap how response format is determined in Rails.

## Response format calculation in Rails

In Rails, the concept of _format_ appears just from the first scaffold command. For example, if you run a simple `bin/rails g scaffold post title`, you can find references to response formats in the controller and also in the routes.

Part of the generated controller looks like the following:

```ruby
class PostsController < ApplicationController

  ...

  # GET /posts
  # GET /posts.json
  def index
    @posts = Post.all
  end

  ...

  # POST /posts
  # POST /posts.json
  def create
    @post = Post.new(post_params)

    respond_to do |format|
      if @post.save
        format.html { redirect_to @post, notice: 'Post was successfully created.' }
        format.json { render :show, status: :created, location: @post }
      else
        format.html { render :new }
        format.json { render json: @post.errors, status: :unprocessable_entity }
      end
    end
  end
end
``` 

In Rails controllers, you have the ability to write code that can respond in different formats. By default, generated code from the scaffold command can respond on HTML or JSON formats. That is easy to see in the `create` action, but it also happens in the `index` action where the render is implicit (this action returns a list of posts and it's rendered in the appropriate format).

Of course, there should be some sort of rule that determines which format is picked to respond the request. In order to understand those rules, let's now take a look at the routes generated by the scaffold.

The following is the output of `bin/rake routes` in our example application:

```
   Prefix Verb   URI Pattern               Controller#Action
    posts GET    /posts(.:format)          posts#index
          POST   /posts(.:format)          posts#create
 new_post GET    /posts/new(.:format)      posts#new
edit_post GET    /posts/:id/edit(.:format) posts#edit
     post GET    /posts/:id(.:format)      posts#show
          PATCH  /posts/:id(.:format)      posts#update
          PUT    /posts/:id(.:format)      posts#update
          DELETE /posts/:id(.:format)      posts#destroy
```

These routes are what you get when you have something like `resources: :post` in your routes file. We can see that _format_ here is a dynamic segment present in every generated routes, and this is the most common way in Rails to decide which is the format used to form a response. So, in many cases the format depends on the extension in the request URL, usually appended by a client application (or client side code if it's a Rails default stack application) to indicate the expected format.

Therefore, a JSON response is generated if you issue a GET request to `http:://mysite.com/posts.json` and HTML response is generated when the URL is `http:://mysite.com/posts.html`. In the case of the `index` action, it just relies on the ability of Rails to render the list of posts in the format value inferred from the route path. If the format is not specified in the request path or it's an unknown format for Rails, the response will be rendered in HTML format if it's a standard Rails application or JSON if it's configured with `config.api_only = true` (using the new API mode).

By using `respond_to`, like in the 'create' action of our `PostController`, you can be specific about the content of the response depending on the specified format. In this case, if the format is not provided it will use the first format listed within the `respond_to` block. If there is not a handler for the specified format, it will raise a `ActionController::UnknownFormat` exception (and it would result in a `406 Not Acceptable` response error).

In general terms, this is a game of two players: we have a client that makes a request to our server and it could *specify* the expected response format and we also have our application server that is *able to respond* in one or more formats. Therefore, the response format should be determined based on what was requested but also considering the list of supported formats in the server. In Rails, adding the format in the URL is the most common way to specify the expected format in the response. This mechanism relies on how things are defined in the routes file and the controller code, as it was described above.

## Defining the format with the HTTP Accept header

In the context of an API application, I personally prefer the use of the HTTP `Accept` header which is also supported in Rails, because this is the manner to specify the response format according to the HTTP protocol. The [HTTP/1.1 RFC](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html) states:

> The Accept request-header field can be used to specify certain media types which are acceptable for the response. 

> ... 

> If no Accept header field is present, then it is assumed that the client accepts all media types. If an Accept header field is present, and if the server cannot send a response which is acceptable according to the combined Accept field value, then the server SHOULD send a 406 (not acceptable) response.

Please note that the term *media type* in the RFC is very close to what we call *format* in Rails.

Relying on the `Accept` header can be handy when the client code is another component like an external application or the frontend part of a web application, because you usually have control of the request headers so you can be explicit about the expected response format without being tied to the request path.

## Responses when something goes wrong in the backend

Let's get into the topic that motivates this post. One special case related with the responses returned by our Rails application are error responses, when an error happens while the request is being processed. One could expect to receive that type of responses in the format that is requested or determined by the rules explained above. However, it is not necessarily the case, at least using Rails 4 or previous versions.

Rails can form error responses on HTML (using the error HTML files that you can find in the `public` folder), JSON and XML. An example of an error response for a JSON request could look like this:

```
{"status":"500","error":"Internal Server Error"}
```

In the current Rails stable version (4.2), error responses are returned in the format that would be used for a successful response in *almost* all cases running the application on production mode. This is not the case when the response format is taken from the request path and the error happens before reaching the Rails's routing code. In these specific cases, the response error code is correct but the request body is empty.

Probably there are just a few cases where the error happens while processing some of the middleware before reaching the part where routes are computed, but it is still an issue that can happen. For example, consider the following request to create a Post based on our `PostController`:

```
url -H "Content-Type:application/json; charset=utf-8" -d '{"post": {"title":"My Post", "invalid value"}}' http://localhost:3000/post.json
```
 
Note that we are using the `Content-Type` header to indicate the format of the values sent among the request.  Rails will attempt to parse the provided JSON value, but it will raise an `ActionDispatch::ParamsParser::ParseError` exception because the JSON is not well-formatted (did you noticed the invalid part in the example?). However, it fails to return an error response in JSON format because the code that parses the `.json` part of the request path is never executed. Instead, it just returns a `400 Bad Request` response but with empty body.
Adding an `Accept` header to ask for JSON responses instead of relying on the `.json` extension in the URL, will cause to return an error response, again with the `400 Bad Request` code, but including a body in the expected format:

```
{"status":"400","error":"Bad Request"}
```

The difference could be very subtle, but if our client component makes any further processing based on the response content in case of errors, we may need to use the `Accept` header to be safe.

As part of our changes related with error responses on Rails, we added some code to respond with the format indicated with the request path even if the exception was raised before executing the router code.
The approach is very simple: we retrieve the format from the extension of the URL if the format is not yet parsed by the router, if we need to form an error response.

Although this way to determine the format is not always equivalent to what is being parsed by the router, because the `:format` fragment could be in any part of the path, we think that will work for all but a few cases. Being honest, I've never seen a Rails application with custom routes where the `:format` fragment is not the extension part of the URL.

You can see what was finally changed for Rails 5 by looking at the `MimeNegotiation#format_from_path_extension` method [here](https://github.com/rails/rails/blob/fc027e1faf39f0deacd734fe0a46eb5ee6d70851/actionpack/lib/action_dispatch/http/mime_negotiation.rb#L166-L171). Also, you can know more about the limitations of this approach when you have routes with constraints in this [discussion](https://github.com/rails/rails/issues/22747#issuecomment-166503385).


## Error responses on development mode

Up to now, we have discussed how error responses are formatted with the default production settings. In fact, there is a specific Rails configuration setting called `action_controller.consider_all_requests_local` that controls how errors are rendered. It's set to `false` by default on `config/environments/production.rb` causing that error responses present the problem in a user-friendly way (generally, an user-oriented error message without exposing internal information about the exception).

In contrast, the `consider_all_requests_local` is set to `true` by default on development mode, and it generates HTML error pages that shows the exception message, the stack trace and also the [web console](https://github.com/rails/web-console) where we can debug the problem executing code on the server. However, you can not get an error response with JSON format on Rails 4.2, because it usually responds with this HTML error page (the only one exception are XHR requests that are returned using a plain text format if an error occurs).

However, with the arrival of the Rails API mode, we found that error responses behaving in the explained way on development mode could not be so convenient when you want to implement a Rails "only API" backend. In many cases, you might want to receive error responses in the format expected by your client component. In this case, the error responses should be formatted in JSON, as it's on production mode, but also including information about the error for debugging purposes.

We actually wanted developers to have the chance to decide how error responses should be. We think it would strongly depend on the interaction with the client component: if you're working exclusively on the backend component, you would prefer to use the HTML error pages since you can better inspect the exception data in a formatted HTML page and take advantage of the web console. In the other hand, if you work integrating both sides, the Rails backend and the client, you would prefer to have JSON error responses, even on development, so they goes into the expected flow in the client component (where you probably already have a way to inspect and debug).

How is it now working in Rails 5? A new configuration key was added to control it: `debug_exception_response_format` and it should be defined in the `config/environments/development.rb` file. It accepts two values: `:default` to render errors in the "Rails 4.2 way" (HTML pages or text error responses for XHR requests) and `:api` to render error responses using the proper format.

If you create a new application with Rails 5, the `debug_exception_response_format` won't be included in the `config/environments/development.rb` file, however it's nice to know that its default value depends on the type of application created. If the API mode is turned on, the default value for `debug_exception_response_format` is `:api`, but if it's not an only API application the default value is `:default`. Therefore, the error responses are the ones that respect the expected format by default in only API applications. Of course, setting the `debug_exception_response_format` in your project is the way to customize it if the Rails' default behavior does not apply to your specific situation.


## A collateral fix for web-console

When we were working on the implementation of all these changes for Rails error responses, we got into some conflict with the `web-console` gem. Right after changing some code to have error responses on development mode returned in JSON format, we found that the `web-console` code was being appended to our JSON response, turning it into an unintelligible messy response including JSON, HTML and JS code at the same time :)

Although that `web-console` was always checking if the response format is HTML before appending the console code, this issue occurred because Rails and `web-console` were using a different approaches to determine the response format. While Rails defines the response format based on the extension in the URL and the Accept headers in the request as explained above, `web-console` was relying on the request `Content-Type` header.
It leaded to a [pull request](https://github.com/rails/web-console/pull/152) where we concluded that `web-console` should stop relying on the `Content-Type` header (since it's should be used to determine the request body format rather than response format according [RFC 2616 section 7.2.1](http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2.1)) and to reuse the format determined in the Rails middleware chain to check whether the console should be appended or not.


## Conclusions

Hope you have now a better undertanding about the format negotiation and error responses in Rails, and the differences between development and production mode. Also, we would like to hear about your experiences developing Rails only API applications with the latest modifications to error responses on development mode. Please send us any feedback to help us to improve the API mode in Rails.

Finally, regarding the format negotiation in Rails, [a discussion is currently happen](https://github.com/rails/rails/issues/20666) about what is the proper way to respond in cases where the expected format is not supported or unknown. It could lead to new modifications or fixes that can slightly alter the behavior commented in the first part of this article.
