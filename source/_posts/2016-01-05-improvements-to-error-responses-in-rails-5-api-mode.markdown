---
layout: post
title: "Improvements to error responses in Rails 5 API mode"
category: 
comments: true
author:
  name: Jorge Bejar
  email: jorge@wyeworks.com 
  twitter_handle: jmbejar
  github_handle: jmbejar
  image: /images/team/jorge-bejar.jpg
  description: Software Engineer at Wyeworks. Ruby on Rails developer.
---

In previous posts, we showed how to build an API application with Rails 5. Specifically, we covered the integration with [Backbone](https://wyeworks.com/blog/2015/6/11/how-to-build-a-rails-5-api-only-and-backbone-application) and [Ember](https://wyeworks.com/blog/2015/6/30/how-to-build-a-rails-5-api-only-and-ember-application). At time of writing these posts, the only way to try out all the new Rails API mode was taking the code from the master branch, since Rails 5 had not been released yet. However, [Rails-5-0-beta1 is available now](http://weblog.rubyonrails.org/2015/12/18/Rails-5-0-beta1/), so you can easily start to build applications using Rails in its new API-flavored mode.

This Rails release also includes some changes related with the API mode that landed in Rails a few weeks ago. The purpose of those changes are improving error responses for JSON requests on Rails. We initiated a discussion about how Rails should handle and return responses in a proper format in case of errors processing a request, and then we finally came up with [the necessary code changes](https://github.com/rails/rails/pull/20831) in Rails.

<!--more-->

Before digging into how error responses were improved, let's recap how response format is determined in Rails.

## Response format calculation in Rails

In Rails, the concept of _format_ appears just from the first scaffold command. For example, if you run a simple `bin/rails g scaffold post title`, you can find references to response formats in the controller and also in the routes.

Part of the generated controller looks like the following:

```ruby
class PostsController < ApplicationController

  ...

  # GET /posts
  # GET /posts.json
  def index
    @posts = Post.all
  end

  ...

  # POST /posts
  # POST /posts.json
  def create
    @post = Post.new(post_params)

    respond_to do |format|
      if @post.save
        format.html { redirect_to @post, notice: 'Post was successfully created.' }
        format.json { render :show, status: :created, location: @post }
      else
        format.html { render :new }
        format.json { render json: @post.errors, status: :unprocessable_entity }
      end
    end
  end
end
``` 

In Rails controllers, you have the ability to write code that can respond in different formats. By default, generated code from the scaffold command can respond on HTML or JSON formats. That is easy to see in the `create` action, but it also happens in the `index` action where the render is implicit (this action returns a list of posts and it's rendered in the appropriate format).

Of course, there should be some sort of rule that determines which format is picked to respond the request. In order to understand those rules, let's now take a look at the routes generated by the scaffold.

The following is the output of `bin/rake routes` in our example application:

```
   Prefix Verb   URI Pattern               Controller#Action
    posts GET    /posts(.:format)          posts#index
          POST   /posts(.:format)          posts#create
 new_post GET    /posts/new(.:format)      posts#new
edit_post GET    /posts/:id/edit(.:format) posts#edit
     post GET    /posts/:id(.:format)      posts#show
          PATCH  /posts/:id(.:format)      posts#update
          PUT    /posts/:id(.:format)      posts#update
          DELETE /posts/:id(.:format)      posts#destroy
```

These routes are what you get when you have something like `resources :post` in your routes file. We can see that _format_ here is inferred from a dynamic segment present in all the generated routes, and this segment matches the URL extension of the request. This is the most common way in Rails to determine the response format.

Therefore, a JSON response is generated if you issue a GET request to `http:://mysite.com/posts.json` and HTML response is generated when the URL is `http:://mysite.com/posts.html`. In the case of the `index` action, it just relies on the ability of Rails to render the list of posts in the format value inferred from the route path. When Rails is not able to infer any format (e.g. absence of extension in the path) or in case of an unknown format, the response will be rendered in HTML format in a standard Rails application or JSON in a API-only application.

By using `respond_to`, like in the 'create' action of our `PostController`, you can be specific about the content of the response depending on the specified format. In this case, if the format is not provided it will use the first format listed within the `respond_to` block. If there is not a handler for the specified format, it will raise a `ActionController::UnknownFormat` exception (and it would result in a `406 Not Acceptable` response error).

In general terms, this is a game of two players: we have a client that makes a request to our server and it could *specify* the expected response format and we also have our application server that is *able to respond* in one or more formats. Therefore, the response format should be determined based on what was requested but also considering the list of supported formats in the server. In Rails, adding the format in the URL is the most common way to specify the expected format in the response. This mechanism relies on how things are defined in the routes file and the controller code, as it was described above.

## Defining the format with the HTTP Accept header

In the context of an API application, I personally prefer the use of the HTTP `Accept` header which is also supported in Rails, because this is the manner to specify the response format according to the HTTP protocol. The [HTTP/1.1 RFC](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html) states:

> The Accept request-header field can be used to specify certain media types which are acceptable for the response. 

> ... 

> If no Accept header field is present, then it is assumed that the client accepts all media types. If an Accept header field is present, and if the server cannot send a response which is acceptable according to the combined Accept field value, then the server SHOULD send a 406 (not acceptable) response.

Please note that the term *media type* in the RFC is what we call *format* in Rails.

Relying on the `Accept` header can be handy when the client code is another component like an external application or the frontend part of a web application, because you usually have control of the request headers so you can be explicit about the expected response format without being tied to the request path.

## Responses when something goes wrong in the backend

Let's get into the topic that motivates this post. One special case related with the responses returned by our Rails application are error responses, when some error occurs while the request is being processed. Rails can form error responses on HTML (using the error HTML files that you can find in the `public` folder), JSON or XML. An example of an error response for a JSON request could look like this:

```
{"status":"500","error":"Internal Server Error"}
```

In Rails 4.2.x, error responses are returned in the format that would be used for a successful response in *almost* all cases, if the application is running on production mode. This is not the case when the response format should be inferred from the request path and the error happens before reaching the Rails's internal routing code. In these specific cases, the response error code is correct but the request body is empty.

Probably there are just a few cases where the error happens executing Rails middleware before reaching the router, but it is still an issue that can happen. In fact, the router code is executed after the entire middleware chain, right before executing the corresponding controller code. For example, consider the following request to create a Post based on our `PostController`:

```

```
 
Note that we are using the `Content-Type` header to indicate the format of the values sent among the request.  Rails will attempt to parse the provided JSON value, but it will raise an `ActionDispatch::ParamsParser::ParseError` exception because the JSON is not well-formed (did you noticed the invalid part in the example?). However, it fails to return an error response in JSON format because the code that parses the `.json` part of the request path is never executed. Instead, it just returns a `400 Bad Request` response but with empty body.
Adding an `Accept` header to ask for JSON responses instead of relying on the `.json` extension in the URL, will cause to return an error response, again with the `400 Bad Request` code, but including a body in the expected format:

```
{"status":"400","error":"Bad Request"}
```

The difference could be very subtle, but if our client component makes any further processing based on the response content in case of errors, we may need to use the `Accept` header to be safe, if we use Rails 4.2 or previous versions.

As part of our changes related with error responses on Rails, we added some code to respond with the format indicated with the request path when an exception was raised before executing the router code.
The approach is very simple: we retrieve the format from the extension of the URL _guessing_ that the format is the extension part of the request path.

This way to determine the format is not always equivalent to what is being parsed by the router, because the `:format` fragment could theorically be in any part of the path. However, we think that will work for all but a very few cases. In fact, I've never seen a Rails application with custom routes where the `:format` fragment is not the extension part of the URL.

You can see what was finally changed for Rails 5 by looking at the `MimeNegotiation#format_from_path_extension` method [here](https://github.com/rails/rails/blob/fc027e1faf39f0deacd734fe0a46eb5ee6d70851/actionpack/lib/action_dispatch/http/mime_negotiation.rb#L166-L171). Also, you can know more about the limitations of this approach when you have routes with constraints in this [discussion](https://github.com/rails/rails/issues/22747#issuecomment-166503385).


## Error responses in development mode

Up to now, we have discussed how error responses are formatted with the default production settings. In fact, there is a specific Rails configuration setting called `action_controller.consider_all_requests_local` that controls how errors are rendered. It's set to `false` by default on `config/environments/production.rb` causing that error responses present the problem in a user-friendly way (generally, an user-oriented error message without exposing internal information about the exception).

In contrast, `consider_all_requests_local` is set to `true` by default in development mode, and it generates the standard Rails HTML error page for debugging that shows the exception message, the stack trace and also the [web console](https://github.com/rails/web-console) where we can execute code on the server, except for XHR requests where error responses are rendered in plain text. Therefore, getting an error response with JSON or other formats is not possible with the default settings for development mode, using Rails 4.2.

With the arrival of the Rails API mode, we found that error responses behaving in this way, in development mode, could not be so convenient when you're working on a Rails API project. In many cases, you may want to receive error responses in the format expected by your client component but also including information about the error for debugging purposes. So, the development error responses would differentiate from production error responses in their content but not in the format used to render them.

We actually wanted developers to have the chance to decide how error responses should be. We think it would strongly depend on the interaction with the client component: if you're working exclusively on the backend component, you would prefer to use the HTML error pages since you can better inspect the exception information in a formatted HTML page and take advantage of the web console. On the other hand, if you work integrating both sides, the Rails backend and the client, you would prefer to have JSON error responses, even in development, so they goes into the expected flow in the client component (where you probably already have a way to inspect and debug problems).

Well, Rails 5 includes some changes that could hopefully help in those cases. A new configuration key was added to control how to render errores in development: `debug_exception_response_format`. It should be defined in the `config/environments/development.rb` file. It accepts two values: `:default` to render errors in the "Rails 4.2 way" (HTML pages or text error responses for XHR requests) and `:api` to render error responses using the proper format.

If you create a new application with Rails 5, the `debug_exception_response_format` won't be included in the `config/environments/development.rb` file, however it's nice to know that its default value depends on the type of application you've created. If the API mode is turned on, the default value for `debug_exception_response_format` is `:api`, and in case of an API-only application the default value is `:default`. Of course, you can use the  `debug_exception_response_format` option to customize the error responses in development if the Rails defaults do not apply to your specific situation.


## A collateral fix for web-console

When we were working on the implementation of all these changes for Rails error responses, we got into some conflicts with the `web-console` gem. We found that the `web-console` browser code was appended to error responses even when those are rendered in JSON, turning it into an unintelligible messy response including JSON, HTML and JS code at the same time &#128514;

Although that `web-console` was always checking if the response format is HTML before appending the console code, this issue occurred because Rails and `web-console` were using different approaches to deduce the response format. While Rails defines the response format based on the extension in the URL and the Accept headers in the request as explained above, `web-console` was relying on the request `Content-Type` header.
It leaded to a [pull request](https://github.com/rails/web-console/pull/152) where we concluded that `web-console` should stop relying on the `Content-Type` header (since it must be used to determine the request body format rather than response format according [RFC 2616 section 7.2.1](http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2.1)). Relying on the format inferred on Rails code, avoiding a separate logic for that in this gem, was good enough to check whether the console should be appended or not.


## Conclusions

Hope you have now a better understanding about the format negotiation and error responses in Rails, and the differences between development and production mode. Also, we would like to hear about your experiences developing API-only Rails applications with the latest modifications to error responses in development mode. Please send us any feedback that can help to improve the API mode in Rails.

Finally, regarding the format negotiation in Rails, [a discussion is currently happening](https://github.com/rails/rails/issues/20666) about what is the proper way to respond in cases where the expected format is not supported or unknown. It could lead to new modifications or fixes that can slightly alter the behavior commented in the first part of this article.
