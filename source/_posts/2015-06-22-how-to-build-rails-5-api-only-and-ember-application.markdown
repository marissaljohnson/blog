---
layout: post
title: How to build Rails 5 API only and Ember application
hero_image: /blog/images/heros/post-high.jpg
comments: true
author:
  name: Santiago Pastorino
  email: santiago@wyeworks.com
  twitter_handle: spastorino
  github_handle:  spastorino
  image:  /images/team/santiago-pastorino.jpg
  description: WyeWorks Co-Founder & CTO, Ruby on Rails Core Team Member
published: true
---

A few days ago, following long discussions, [Rails API was merged into Rails master branch](https://github.com/rails/rails/pull/19832).

Because of that, in our latest post we discussed how to build an API only application. We've also shown how to integrate it with a client-side application implemented using Backbone. If you've missed this post, check it out and learn more about [how to integrate Rails API with an Backbone application](http://wyeworks.com/blog/2015/6/11/how-to-build-a-rails-5-api-only-and-backbone-application).

In this post, we are going to show how a very similar client-side application now built with Ember can be integrated with the same backend application implemented using Rails API. Like in our previous post, we are going to use the [TodoMVC application](http://todomvc.com).

In addition, we are going to comment about some issues that were fixed in Rails and Active Model Serializers in order to make the integration easier. These improvements were the result of testing Rails API with an Ember application, as part of our efforts to try it out using some popular JavaScript frameworks.


## Building the Backend

### Generate the Rails API only application

First of all, we need to generate a new Rails API only application from scratch. Rails 5 is not released yet, so we have to clone the Github repository and generate our application directly from the source code.

<pre>git clone git://github.com/rails/rails.git
cd rails
bundle exec railties/exe/rails new /tmp/my_api_app --api --edge</pre>

In case you want a detailed explanation about the list of directories and files generated by this command, please take a look at [our previous post](http://wyeworks.com/blog/2015/6/11/how-to-build-a-rails-5-api-only-and-backbone-application). 

However, if we compare with what was described in our previous blog post, we can see a subtle difference in the generated Gemfile: [the `active-model-serializer` gem version changed from  0.10.0.rc1 a 0.10.0.rc2](https://github.com/rails/rails/commit/16db36b56685517c76385f9e0f877a9015bde2ca).

The new Active Model Serializer release candidate includes a [new adapter that works properly with the Ember's RESTAdapter](https://github.com/rails-api/active_model_serializers/pull/958). This addition simplified a lot the integration of our Rails API only backend and the Ember client-side application.


### Scaffolding the Todo resource

The Todo items in the Ember application have two attributes: a string `title` and a boolean `isCompleted`. The following step to build our backend application is precisely to add a resource representing these Todo items.

We can do it just running the `rails generate scaffold` command:

<pre>bin/rails g scaffold todo title isCompleted:boolean</pre>

Since we're now using a new version of the `active-model-serializer` gem, specifically the version 0.10.0.rc2, the scaffold command generates the serializer file for this resource. At the time of writing our previous post, we had to run another command to generate the serializer. It is now changed to be automatically run along the scaffold generator. In fact, this was [an enhancement implemented only a few days ago](https://github.com/rails-api/active_model_serializers/commit/4752e6723a6e0e8c4038ed4f36b87a954ad21097).

Don't forget to run `bin/rake db:migrate` to update the database
schema.

### Choose the appropriate JSON serialization format

Our Rails API only application is going to respond incoming requests in a given JSON format. The process to convert the data into this format is called serialization and this will be possible in our backend application thanks to Active Model Serializer adapters.

By default, Active Model Serializer uses a format provided by the `flatten_json` adapter which is a very simple format that only includes the list of attributes without any additional metadata about the data being serialized. For instance, using this adapter, a Todo item would be serialized like:

<pre>
{
  "id": 1,
  "title": "Todo 1",
  "isCompleted": false
}
</pre>

Luckily, we have an additional adapter shipped with Active Model Serializer in 0.10.0.rc2, which gives us more flexibility. In particular, we need to pick a JSON format matching our Ember application. We can achieve that selecting a format that works well with the Ember's RESTAdapter. The main requirement specified by the RESTAdapter is the presence of the **root object's key** as part of the JSON payload, as it is explained in the [Ember RESTAdapter documentation](http://guides.emberjs.com/v1.10.0/models/the-rest-adapter). It means we want to serialize a Todo item like this:

<pre>
{
  "todo": {
    "id": 1,
    "title": "Todo 1",
    "isCompleted": false
  }
}
</pre>

This is easy to do with Active Model Serializer if we choose the `json` adapter instead of the `flatten_json`. We can configure it by creating a new initializer file `config/initializers/ams_json_adapter.rb` including the following line:

<pre>ActiveModel::Serializer.config.adapter = :json</pre>

At this point, the backend application should be ready, so it's testing time! Start the web server with `bin/rails s` and let's create our first Todo using `curl`:

<pre>curl -H "Content-Type:application/json; charset=utf-8" -d '{"todo": {"title":"Todo 1","isCompleted":false}}' http://localhost:3000/todos</pre>

The API application should return the created item serialized in JSON format, including the root element:

<pre>{"todo": {"id":1,"title":"Todo 1","isCompleted":false}}</pre>

Now, let's get the Todo items list:

<pre>curl http://localhost:3000/todos</pre>

and the response should look like this (note the root element in plural):

<pre>{"todos": [{"id":1,"title":"Todo 1","isCompleted":false}]}</pre>

## Integrating with the Ember client-side application

We want to have both components working together, integrating our Rails API only application with the Todo list frontend application implemented with Ember.

The [original implementation from TodoMVC](https://github.com/tastejs/todomvc/tree/gh-pages/examples/emberjs) is our starting point, but we must do a few changes to have it working properly with our backend. In fact, the TodoMVC Ember example uses the browser local storage to persist Todo items, but we want to have our Rails API application doing this job.

After downloading the Ember application code from TodoMVC, we need to have a newer version of the `ember-data` library to integrate properly this frontend application with Rails API because the provided does an infinite PUTs loop, [more info here](https://github.com/tastejs/todomvc/pull/1343). `npm update` updates all the dependencies but ember and ember-data because they are not distributed with npm yet. So we need to update this library by hand using curl:

<pre>curl http://builds.emberjs.com/release/ember-data.js > node_modules/ember-data/ember-data.js</pre>

We have now all the vendored JavaScript code updated, so we are prepared to connect the frontend with our Rails backend. We configure that by changing the Ember adapter from LSAdapter (local storage) to RESTAdapter. You can learn more about Ember adapters [in the Ember documentation page](http://emberjs.com/api/data/classes/DS.Adapter.html).

Let's replace the following piece of code in the `js/app.js` file:

```js
  Todos.ApplicationAdapter = DS.LSAdapter.extend({
    namespace: 'todos-emberjs'
  });
```

with the RESTAdapter's definition pointing to our backend:

```js
  Todos.ApplicationAdapter = DS.RESTAdapter.extend({
    host: 'localhost:3000'
  });
```

Finally, we have to configure CORS in the Rails API only backend because both applications will run in different domains (we will test the backend in `localhost:3000` and the client-side application in `localhost:9000`).

In brief, we need to uncomment the `rack-cors` gem reference in the `Gemfile`, run `bundle install` and finally put the following code in the `config/initializers/cors.rb` file:

```ruby
# Avoid CORS issues when API is called from the frontend app
# Handle Cross-Origin Resource Sharing (CORS) in order to accept cross-origin AJAX requests

# Read more: https://github.com/cyu/rack-cors

 Rails.application.config.middleware.insert_before 0, "Rack::Cors" do
   allow do
     origins 'localhost:9000'

     resource '*',
       headers: :any,
       methods: [:get, :post, :put, :patch, :delete, :options, :head]
   end
 end
```

You can read more about how to setup CORS in our [previous post](http://wyeworks.com/blog/2015/6/11/how-to-build-a-rails-5-api-only-and-backbone-application).

We are now ready to test the whole application! Run the backend server with:

<pre>bin/rails s</pre>

and start a simple web server to test the Ember application:

<pre>ruby -run -e httpd . -p 9000</pre>

You can already try it out and start adding your first Todo items, just browse to [localhost:9000](http://localhost:9000).

## Conclusion


